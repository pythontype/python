线性表是一种典型的线性结构。头部点无前驱有一个后继，未接点无后继有一个前驱。链表只能顺序查找，定位一个元素的时间为O(N),删除
一个元素的时间为O(1)

1、线性表的顺序存储结构：把线性表的节点按逻辑顺序依次存放在一组地址连续的存储单元里，用这种方法存储的线性表简称顺序表。是一种
随机存取的存储结构。顺序存储指内存地址是一块的，随机存取指访问时可以按下表随机访问，存储和存取是不一样的。如果是存储，则是指按
顺序的，如果是存取，则可以是随机的，可以利用元素下标进行。数组比线性表速度更快的是：原地逆序、返回中间节点、选择随机节点。

。 便于线性表的构造和任意元素的访问
。 插入：插入新节点，之后节点后移。平均时间复杂度：O(n)
。 删除：删除节点，之后节点后移。平均时间复杂度：O(n)

2、线性链表：用一组任意的存储单元来依次存放线性表的结点，这组存储单元即可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意
位置上的。因此，链表中结点的逻辑次序和物理次序不一定相同。为了能正确表示结点间的逻辑关系，在存储每个结点值的同时，还必须存储指示
其后继结点的地址。data域是数据域，用来存放结点的值。next是指针域（亦称链域），用来存放结点的直接后继的地址（或位置）。不需要事先
估计存储空间大小。
单链表中每个结点的存储地址是存放在其前趋结点next域中，而开始结点无前趋，故应设头指针head指向开始结点。同时，由于最后一个结点无后
继，故结点的指针域为空，即NULL。头插法建表(逆序)、尾插法建表(顺序)。增加头结点的目的是算法实现上的方便，但增大了内存开销。
查找：只能从链表的头指针出发，顺链域next逐个结点往下搜索，直到搜索到第i个结点为止。因此，链表不是随机存取结构。
插入：先找到表的第i-1的存储位置，然后插入。新结点先连后继，再连前驱。
删除：首先找到ai-1的存储位置p。然后令p–>next指向ai的直接后继结点，即把ai从链上摘下。最后释放结点ai的空间.r=p->next;p->next=r->next;delete r。
判断一个单向链表中是否存在环的最佳方法是快慢指针。
静态链表：用一维数组来实现线性链表，这种用一维数组表示的线性链表，称为静态链表。静态：体现在表的容量是一定的。（数组的大小）；链表：插入
与删除同前面所述的动态链表方法相同。静态链表中指针表示的是下一元素在数组中的位置。
静态链表是用数组实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配大小。动态链表是用申请内存函数（C是malloc,C++是new）动态申请内存
的，所以在链表的长度上没有限制。动态链表因为是动态申请内存的，所以每个节点的物理地址不连续，要通过指针来顺序访问。静态链表在插入、删除时也是通过修
改指针域来实现的，与动态链表没有什么分别
循环链表：是一种头尾相接的链表。其特点是无须增加存储量，仅对表的链接方式稍作改变，即可使得表处理更加方便灵活。
在单链表中，将终端结点的指针域NULL改为指向表头结点的或开始结点，就得到了单链形式的循环链表，并简单称为单循环链表。由于循环链表中没有NULL指针，故涉
及遍历操作时，其终止条件就不再像非循环链表那样判断p或p—>next是否为空，而是判断它们是否等于某一指定指针，如头指针或尾指针等。
双向链表:在单链表的每个结点里再增加一个指向其直接前趋的指针域prior。这样就形成的链表中有两个方向不同的链。双链表一般由头指针唯一确定的，将头结点和尾
结点链接起来构成循环链表，并称之为双向链表。设指针p指向某一结点，则双向链表结构的对称性可用下式描述：p—>prior—>next=p=p—>next—>prior。从两个方向
搜索双链表，比从一个方向搜索双链表的方差要小。
插入：先搞定插入节点的前驱和后继，再搞定后结点的前驱，最后搞定前结点的后继。
在有序双向链表中定位删除一个元素的平均时间复杂度为O(n)
可以直接删除当前指针所指向的节点。而不需要像单向链表中，删除一个元素必须找到其前驱。因此在插入数据时，单向链表和双向链表操作复杂度相同，而删除
数据时，双向链表的性能优于单向链表
